{"meta":{"title":"格子格子","subtitle":"","description":"","author":"LZQ","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"next blog","slug":"next-blog","date":"2020-10-30T14:30:50.000Z","updated":"2020-10-30T14:30:50.526Z","comments":true,"path":"2020/10/30/next-blog/","link":"","permalink":"http://example.com/2020/10/30/next-blog/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"IO函数","date":"2020-10-22T23:01:55.196Z","updated":"2020-10-09T14:42:36.999Z","comments":true,"path":"2020/10/23/IO函数/","link":"","permalink":"http://example.com/2020/10/23/IO%E5%87%BD%E6%95%B0/","excerpt":"","text":"I/O函数printf( )函数%[flags] [width] [.prec] [hiL] type scanf( )函数scanf的基本格式scanf(“格式化字符串”，参数列表)； 格式化字符串 表明字符输入流的目标数据类型 参数列表 指向变量的指针 scanf()的转换说明符常用 转换说明符 意 义 %u 把输入解释成一个无符号十进制整数 %c 把输入解释成一个字符 %d 把输入解释成一个有符号十进制整数 %e，%f，%g， %a 把输入解释成一个浮点数 (%a是C99标准) %p 把输入解释成一个指针（地址） %s 把输入解释成一个字符串；输入的内容以一个非空白字符作为开始，并且包含直到下一个空白字符的全部字符 scanf()的转换修饰符常用 转换说明 含意 * 抑制赋值 数字 最大字段宽度输入达到最大字段宽度处停止","categories":[],"tags":[]},{"title":"","slug":"C语言：记录","date":"2020-10-22T23:01:55.193Z","updated":"2020-10-03T14:13:32.986Z","comments":true,"path":"2020/10/23/C语言：记录/","link":"","permalink":"http://example.com/2020/10/23/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E8%AE%B0%E5%BD%95/","excerpt":"","text":"笔记printf()的转换说明修饰符（部分）数字指最小字段宽度。 若打印的字符宽度小于数字，则在前方加上空格。 12printf(&quot;0%3d0\\n&quot;,3); printf(&quot;%06d0\\n&quot;,6); 输出: 1230 60 .数字指精读 %e %E %f(浮点数) 小数点右边数字的位数 %g %G 有效数字的最大个数 %s 待打印字符的最大数量 整形转换 待打印数字的最大位数 -待打印项左对齐。即，从字段的左侧开始打印该项。 12printf(&quot;%-3d0\\n&quot;,3);printf(&quot;%-6d0\\n&quot;,6); 输出： 123 06 0 +有符号值若为正，则在值前面显示加号；若为负，则在值前面显示减号。 scanf多组样例输入1while(scanf(&quot;%d&quot;,&amp;k)!=EOF) 此类多实例测试解决方案：while(scanf(“%d%d”,&amp;a,&amp;b)!=EOF){//读入一组测试数据//处理//输出结果}注：EOF是宏定义常量-1，scanf函数遇到文件结束标志函数返回值是-1，键盘输入时，ctrl+z表示输入结束例如：while(scanf(“%d%d”,&amp;a,&amp;b)!=EOF) printf(“%d\\n”,a+b); fabs(a)＜1e－10如果fabs(a)＜1e－6，则默认a=0. 123fabs(a)＜1e－6;//fabs()为浮点数的绝对值//库函数为math.h C语言中浮点运算是有精度限制的，在经过很多次运算之后，这个误差会累积下来，理论上等于0，但由于精度问题，C语言算出来不是0，这种情况经常有。所以设定一个限度，认为绝对值小于0.000001就是0了，这个0.000001是经验值，实践中表现的比较好. 在浮点数的除法运算时，要注意这个问题。 数据类型溢出问题 ZZULIOJ 1063: 最大公约与最小公倍输入输入两个正整数n和m（n,m&lt;=1000000)。输入保证最终结果在int范围内。 数据较大的数据在运行过程中可能发生数据溢出。 一般乘法可能溢出，但是除法一定不会溢出。因此同时存在乘法和除法运算的式子里应该先写除法，避免过程溢出。 保险起见数据类型还是应该改为double以保证风险最小 数据类型 字节 范围 int 4 （-2^31～2^31-1） long int 或 long 4 -2^31(-2 147 483 648) ~ 2^31-1(2 147 483 647) long long int 或 long long 8 -2^63(-9.2233720368548e+18) ~ 2^63-1(9.2233720368548e+18) float 4 -/+3.4e38（精确到6位小数） double 8 -/+1.7e308（精确到15位小数） c中nan，inf详解nan： not a number 非数字 注意事项：对负数开方sqrt(-1.0)、 对负数求对数(log(-1.0))、 0.0/0.0、 0.0*inf、 inf/inf、 inf-inf 这些操作都会得到nan。 (0/0会产生操作异常；0.0/0.0不会产生操作异常，而是会得到nan) 辨别方法：isnan() : ture is a nan, false otherwise 123456789101112isnan(NaN) &#x3D; trueisnan(Inf) &#x3D; falseisnan(0.0) &#x3D; falseisnan(DBL_MIN&#x2F;2.0) &#x3D; falseisnan(0.0 &#x2F; 0.0) &#x3D; trueisnan(Inf - Inf) &#x3D; true inf : infinity 无穷大的数，一般是超过浮点数的表示范围。 注意事项： 1.0/0.0等于inf，-1.0/0.0等于-inf，0.0+inf=inf； 1.0/inf等于0.0 inf是可以与其他浮点数进行比较的，即可以参与&lt;=、&gt;+、==、!=等运算。 1辨别方法：isinf(): ture is a nan, false otherwise 123456789isinf(NaN) = falseisinf(Inf) = trueisinf(0.0) = falseisinf(exp(800)) = trueisinf(DBL_MIN/2.0) = false 另一个辨别方法：isfinite(): ture is a finite value, false otherwise。可用来一起判断inf和nan。 123456789isfinite(NaN) = falseisfinite(Inf) = falseisfinite(0.0) = trueisfinite(exp(800)) = falseisfinite(DBL_MIN/2.0) = true","categories":[],"tags":[]},{"title":"","slug":"C语言：结构类型","date":"2020-10-22T23:01:55.191Z","updated":"2020-09-16T18:09:27.256Z","comments":true,"path":"2020/10/23/C语言：结构类型/","link":"","permalink":"http://example.com/2020/10/23/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"C语言：结构与其他数据类型通过结构变量提高表达数据的能力. 为结构建立一个格式或者样式. 声明一个适合该样式的变量. 访问结构变量的各个部分. 结构基本使用建立结构声明结构声明描述一个结构的组织布局. 如: 12345struct book&#123; //struct 标记名 char title[10]; //结构成员列表(任意数据类型或者结构) char author[10]; float value;&#125;; //分号;表示该 结构声明 结束 结构声明(模板)仅仅该对象由什么组成,并未创建实际的对象. 定义结构变量1234567struct book&#123; char title[10]; char author[10]; float value;&#125;; //建立结构声明struct book library; //创建了一个结构变量library,该变量的结构布局是book 简化形式: 12345struct book&#123; //sturct 标记名 (如果该模板仅仅使用一次,可省略) char title[10]; //成员表或成员函数 char author[10]; float value;&#125;library; //结构体变量表,可以同时定义多个结构体变量,用逗号隔开 初始化结构与初始化数组语法类似. 使用一对花括号,各个初始化项用逗号分隔. 如: 12345struct book&#123; abcdefghij, klmnopqrst, 1.9&#125;; 访问结构成员使用结构成员运算符—-点(.)访问结构中的成员 123456library.value=3 ; //对结构中float类型变量value进行赋值struct book library=&#123;.value=3&#125;; //结构的初始化器printf(&quot;%f&quot;,&amp;library.value); //由此可见逗号(,取成员)的优先级高于&amp;(取地址) 向函数传递结构的信息传递结构 结构作为函数参数 整个结构可以作为参数的值传入函数 这时候是在函数内新建一个结构变量,并复制调用者的结构的值 只是传递了原结构的值 也可以返回一个结构 可以通过返回这个结构给调用者，解决传入函数的是外面那个结构的克隆体而原结构没有改变的问题。（同类型结构可以直接赋值） 传递结构的地址 “If a large structure is to be passed to a function, it is generally more efficient to pass a pointer than to copy the whole structure” —— K&amp;R 例： 12345678910111213struct date&#123; int month; int day; int year;&#125;myday; //声明与初始化结构指针struct date *p=&amp;myday; //定义了一个指向struct date模板类型的指针变量，并被赋上myday的地址(*p).month=12; //常规方式1p-&gt;month=12; //方式2，（更加简洁） 用-&gt;表示指针所指的结构变量中的成员 123456struct point* getStruct(struct point *p)&#123; scanf(&quot;%d&quot;, &amp;p-&gt;x); scanf(&quot;%d&quot;, &amp;p-&gt;y); printf(&quot;%d,%d&quot;,&amp;p-&gt;x,&amp;p-&gt;y); return p;//方便接下来有函数调用，提高程序简洁度&#125; 结构数组1struct book library [10]; 以上代码把library声明为一个内含10个元素的数组。数组的每一个元素都是book类型的结构变量 嵌套结构一个结构包含另一个结构。 123456789101112131415161718192021struct point &#123; int x; int y;&#125;;//rectangle结构里的成员也是结构pointstruct rectangle&#123; struct point ptl; struct point pt2;&#125;int x1;//如果有变量定义：struct rectangle r,*rp;rp =&amp;r;//那么下面的四种形式是等价的：x1 = r.ptl.x x1 = rp-&gt;ptl.x x1 = (r.ptl).x x1 = (rp-&gt;ptl).x 枚举枚举 是一种用户定义的数据类型。 枚举类型可以声明符号名称来表示整型常量。 目的：提高程序可读性和可维护性。 它用关键字enum以如下语法来声明： 1enum 枚举类型名字&#123;名字0....（枚举符）..名字n&#125;； 枚举类型名字通常并不真的使用,要用的是在大括号里的名字 因为它们就是就是常量符号,它们的类型是int,值则依次从0到n。 1enum colors&#123;red, yellow.,green&#125;; 创建了三个常量,red的值是0, yellow是1,而 green是2 当需要一些可以排列起来的常量值时,定义枚举的意义就是给了这些常量值名字。 联合联合是一种数据类型，它能够在同一个内存空间中储存不同的数据类型。 储存 所有的成员共享一个空间 同一时间只有一个成员是有效的 union的大小是其最大的成员 初始化 对第一个成员做初始化 自定义数据类型（typedef）C语言提供了一个叫做 typedef的功能来声明一个已有的数据类型的新名字。 声明类型新的名字 新的名字是某种类型的别名 改善了程序的可读性 比如: 123typedef int Length;typedef struct&#123;int x;int y;&#125; rect;//typedef 原类型名称 新名字 使得 Length成为int类型的别名。这样, Length这个名字就可以代替int出现在变量定义和参数声明的地方了: 12Length a, b, len;Length numbers[10];","categories":[],"tags":[]},{"title":"","slug":"C语言：程序结构","date":"2020-10-22T23:01:55.188Z","updated":"2020-10-22T23:06:29.192Z","comments":true,"path":"2020/10/23/C语言：程序结构/","link":"","permalink":"http://example.com/2020/10/23/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/","excerpt":"","text":"title: C语言：程序结构date:tags: C语言：程序结构全局变量 定义在函数外面的变量是全局变量 全局变量具有全局的生存期和作用域 它们与任何函数都无关 在任何函数内部都可以使用它们 如果函数内部存在与全局变量同名的变量,则全局变量被隐藏 全局变量初始化 没有做初始化的全局变量会得到0值 指针会得到NULL值 只能用编译时刻已知的值来初始化全局变量 它们的初始化发生在main函数之前 注意 不要使用全局变量来在函数间传递参数和结果 尽量避免使用全局变量 使用全局变量和静态本地变量的函数是线程不安全的 *返回指针的函数 返回本地（局部）变量的地址是危险的 返回全局变量或静态本地变量的地址是安全的 返回在函数内 malloc的内存是安全的,但是容易造成问题 最好的做法是返回传入的指针 静态本地变量 在本地变量定义时加上 static修饰符就成为静态本地变量 当函数离开的时候,静态本地变量会继续存在并保持其值 静态本地变量的初始化只会在第一次进入这个函数时做,以后进入函数时会保持上次离开时的值 静态本地变量实际上是特殊的全局变量 它们位于相同的内存区域 静态本地变量具有全局的生存期,函数内的局部作用域 static在这里的意思是局部作用域(本地可访问) 宏定义12#define PX printf(&quot;x is %d.\\n&quot;,x)//预处理器指令——宏——替换体 编译预处理指令 #开头的是编译预处理指令 不是C语言的成分，但是C语言程序离不开 #define用来定义一个宏 宏 如果一个宏的值中有其他的宏的名字,也是会被替换的 如果一个宏的值超过一行,最后一行之前的行末需要加\\ 宏的值后面出现的注释不会被当作宏的值的一部分 没有值的宏1#define_DEBUG 这类宏是用于条件编译的,后面有其他的编译预处理指令来检查这个宏是否已经被定义过了 预定义的宏12345_LINE_ //源代码此时行号_FILE_ //源代码文件_DATE_ //源代码日期_TIME_ //源代码时间_STDC_ 带参数的宏12#define MEAN(x,y) ( (x)+(y)/2 ) //宏(宏参数) 替换体 在#define中使用参数可以创建外形与作用与函数类似的类函数宏. 一切都要括号 整个值都要括号 参数出现的每个地方都要括号 可以带多个参数 也可以组合（嵌套）使用其他的宏","categories":[],"tags":[]},{"title":"","slug":"C语言：数组","date":"2020-10-22T23:01:55.186Z","updated":"2020-09-05T09:06:12.647Z","comments":true,"path":"2020/10/23/C语言：数组/","link":"","permalink":"http://example.com/2020/10/23/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E6%95%B0%E7%BB%84/","excerpt":"","text":"C语言：数组数组由数据类型相同的一系列元素组成是一种容器(放东西的东西),由连续的储存单元组成。特点是: 其中所有的元素具有相同的数据类型; 一旦创建,不能改变大小(数组中的元素在内存中是连续依次排列的) 定义数组&lt;类型&gt;变量名称[元素数量]例 12int grades[100]:double weight[20]; 元素数量必须是整数 数组的单元 数组的每个单元就是数组类型的一个变量 使用数组时放在[中的数字叫做下标或索引,下标从0开始计数: 初始化数组数组的集成初始化 1int a[ ] &#x3D;&#123;2,4,6,7,1,3,5,9,11,13,23,14,32&#125; 直接用大括号给出数组的所有元素的初始值 不需要要给出数组的大小,编译器替你数数1234567int count [number] &#x3D;&#123;0)；for（i&#x3D;0; i&lt;number; i++) &#123;count[i]&#x3D;0;&#125;&#x2F;&#x2F;上面两种初始化方式效果相同 指定初始化器可以初始化指定的数组元素 1int a[5]&#x3D;&#123;[4]&#x3D;1&#125;; 对于一般初始化，在初始化一个元素后，未初始化的元素都会被设置为0. 如果指定初始化器后面有更多值，后面的值将被用于初始化指定元素后面的元素 如果再次初始化指定元素，后者会覆盖之前的初始化。 对于未指定元素大小数组的初始化，编译器会设置一个刚好恰当的值。数组的大小sizeof给出整个数组所占据的内容的大小,单位是字节12sizeof(a)&#x2F;sizeof(a[0]) sizeof(a[0])给出数组中单个元素的大小,于是相除就得到了数组的单元个数遍历数组 注：数组作为函数参数时，往往必须再用另一个参数来传入数组的大小。 数组作为函数的参数时: * 不能在中给出数组的大小 不能再利用 sizeof来计算数组的元素个数! 二维数组二维数组的初始化123456789int a[][5]&#x3D;&#123;&#123;0,1,2,3,4&#125;,&#123;2,3,4,5,6&#125;,&#125;;&#x2F;&#x2F;或者：int b[2][3]&#x3D;&#123;1,2,3,4,5,6&#125;;&#x2F;&#x2F;表示 12 34 56 列数是必须给出的,行数可以由编译器来数 每行一个{},逗号分隔 最后的逗号可以存在,有古老的传统 如果省略,表示补零 也可以用定位(C99ON) 注意大数组要定义在主函数外部的原因 全局变量在静态存储区内分配内存 局部变量是在栈内分配内存空间的 C语言编写的程序会在运行期间创建一个栈堆段，用来保存函数的调用关系和局部变量。 而在main函数内部定义大数组相当于在栈内需要一个很大的空间，会造成栈的溢出。因此，当我们需要定义一个极大的数组时，最好在mian 函数外部定义这个大数组。","categories":[],"tags":[]},{"title":"","slug":"C语言：指针","date":"2020-10-22T23:01:55.183Z","updated":"2020-08-28T15:15:44.049Z","comments":true,"path":"2020/10/23/C语言：指针/","link":"","permalink":"http://example.com/2020/10/23/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E6%8C%87%E9%92%88/","excerpt":"","text":"C语言：指针从根本上看， 指针(pointer)是一个值为内存地址的变量（或者数据对象）。 运算符 &amp;：查找地址&amp;，可以获得变量的地址，它的操作数必须是变量。 12345678910int a=3;int *ptr1;//变量类型为储存int类型变量地址的指针ptr1=&amp;a ; //把a的地址赋给指针ptr1//对于这条语句，可以说ptr“指向”a。//a是可以修改的变量，&amp;a是常量printf(&quot;a的地址为%p\\n&quot;,&amp;a);//%p 是输出地址的转化说明，通常将地址以十六进制输出。 指针变量就是保存地址的变量。 1234int* p.q; int *p,q;//两者含义均相同。//p为一个指针，q为一个int变量 普通变量的值是实际的值 指针变量的值是具有实际值的变量的地址。 间接运算符：*单目运算符，后跟一个指针名或地址时，*给出储存在指针指向地址上的值。 可以做右值，也可以做左值。 指针的类型 无论指向什么类型,所有的指针的大小都是一样的,因为都是地址 但是指向不同类型的指针是不能直接互相赋值的 这是为了避免用错指针 使用指针在函数间通信初级应用场景一： 函数返回多个值,某些值就只能通过指针返回 传入的参数实际上是需要保存带回的结果的变量 函数往往只能返回一个值，并且函数内定义的变量与main里的变量无关（本地变量），所以对于要返回多个变量函数的情况，可以通过指针在函数间通信。 例如： 123456789101112131415161718//swap #include&lt;stdio.h&gt;void swap(int*a,int*b);int main&#123; int a=3; int b=4; printf(&quot;a=%d,b=%d/n&quot;,a,b); swap(&amp;a,&amp;b);//向swap函数传递变量a,b的地址 printf(&quot;a=%d,b=%d/n&quot;,a,b); return 0&#125;void swap(int*a,int*b)&#123; //指针让swap函数通过局部变量改变main中的值。 int temp; temp=*a;//*a,*b表示a,b地址所指向的变量的值，可以写入与读取。 *a=*b; //a的值等于 *（&amp;a) *b=temp;&#125; 初级应用场景二 函数返回运算的状态,结果通过指针返回· 常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错， 1或0(在文件操作会看到大量的例子) 但是当任何数值都是有效的可能结果时,就得分开返回 例如： 123456789101112131415161718192021222324#include &lt;stdio. h&gt;//如果除法成功,返回1;否则返回0 * int divide(int a, int b, int *result);int main(void) &#123; int a=5; int b=2; int c; if divide(a, b, &amp;c))&#123; printf(&quot;d/%d=%d\\n&quot;, a, b, c); &#125; else&#123; printf(&quot;除数为0&quot;) &#125; return 0; &#125; int divide(int a, int b, int *result) &#123; int ret =1; if(b==0) ret =0; else &#123; *result=a/b; &#125; return ret;&#125; 常见错误 定义了指针变量,还没有指向任何变量,就开始使用指针 数组与指针数组变量是特殊的指针 数组的地址1234int a[10];printf(&quot;%p\\n&quot;,&amp;a);printf(&quot;%p\\n&quot;,a);printf(&quot;%p\\n&quot;,&amp;a[0]); 如上，所取出的3个地址均相同，都为数组首元素的内存地址。 由此，数组名为数组首元素的地址。 1a==&amp;a[0];//数组名为数组首元素的地址 数组单元的地址12int a[10];printf(&quot;%p\\n&quot;,&amp;a[0]); 相邻的数组单元地址123int a[10];printf(&quot;%p\\n&quot;,&amp;a[0]);pintf(&quot;%p\\n&quot;,&amp;a[1]); 对于int类型的数组，相邻数组单元差距一直为4。 数组变量是特殊的指针数组变量本身表达地址,所以 12int a[10]; int*p=a; //无需用&amp;取地址,p则表示a数组的首单元地址。 但是数组的单元表达的是变量,需要用&amp;取地址 1a==&amp;a[0] 设有数组a,指向a的指针变量pa，则有以下关系：pa,a,&amp;a[0]均指向同一单元，是数组a的首地址，也是0号元素a[0]的地址。 pa+1,a+1,&amp;a[1]均指向第2号元素，pa+i,a+i,&amp;a[i]均指向第i号元素. pa是变量，而a，&amp;a[i]是常量。 运算符可以对数组做,也可以对指针做 p[0] &lt; = = &gt; a[0] 运算符可以对指针做,也可以对数组做: *a=25与a[0]=25效果相同 数组变量是 const的指针,所以不能被赋值 指针与const指针是const表示一旦得到了某个变量的地址,不能再指向其他变量 123int *const p=&amp;i;//p是const*p=26;//OKp++;//ERROR 所指是const表示不能通过这个指针去修改那个变量 (并不能使得那个变量成为 const) 12345678const int *p=&amp;i;//或者写为int const* p2=&amp;i;//const在*前面则为“所指是const”*p=26;//ERROR!不能通过指针修改i=26;//OK（*p)是constK =&amp;j; //OK 转换总是可以把一个非const的值转换成const的 12345678void f(const int*x);int a=15f(&amp;a);// ok const int b=a;f(&amp;b); // ok b=a+1; // Error! 场景：当要传递的参数的类型比地址大的时候,这是常用的手段: 既能用比较少的字节数传递值给参数, 又能避免函数对外面的变量的修改 const 数组 数组变量已经是 const的指针了,这里的 const表明数组的每个单元都是 const int 所以必须通过初始化进行赋值 保护数组值 因为把数组传入函数时传递的是地址,所以那个函数内部可以修改数组的值 为了保护数组不被函数破坏,可以设置参数为 const int sum(const int a[ ], int length); 指针操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// ptr_ops.c -- pointer operations#include &lt;stdio.h&gt;int main(void)&#123; int a[5] = &#123;100,200,300,400,500&#125;; int * ptr1, * ptr2, *ptr3; ptr1 = a; // 把数组a的地址赋给指针 ptr2 = &amp;a[2]; // 把数组第三个单元的地址赋给指针 printf(&quot;指针变量的值:%p\\n&quot;,ptr1); printf(&quot;指针所指地址储存的值:*ptr1 =%d\\n&quot;,*ptr1); //解引用（dereferenced pointer）：*运算符给出指针指向地址上存储的值。 printf(&quot;指针地址:&amp;ptr1 =%p\\n&quot;,&amp;ptr1);//取址，指针变量本身的地址 // 指针加法 ptr3 = ptr1 + 4;//ptr1+4与&amp;a[4]等价 printf(&quot;\\n adding an int to a pointer:\\n&quot;); printf(&quot;ptr1 + 4 = %p, *(ptr1 +4) = %d\\n&quot;,ptr1 + 4, *(ptr1 + 4)); // 一个指针减去一个整数 printf(&quot;\\n subtracting an int from a pointer:\\n&quot;); printf(&quot;ptr3 = %p, ptr3 - 2 = %p\\n&quot;,ptr3, ptr3 - 2); ptr1++; // 递增指针 printf(&quot;\\n values after ptr1++:\\n&quot;); printf(&quot;ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\\n&quot;,ptr1, *ptr1, &amp;ptr1); ptr2--; // 递减指针 printf(&quot;\\nvalues after --ptr2:\\n&quot;); printf(&quot;ptr2 = %p, *ptr2 = %d, &amp;ptr2 = %p\\n&quot;,ptr2, *ptr2, &amp;ptr2); --ptr1; // 恢复为初始值 ++ptr2; // 恢复为初始值 printf(&quot;\\n Pointers reset to original values:\\n&quot;); printf(&quot;ptr1 = %p, ptr2 = %p\\n&quot;,ptr1, ptr2); // 一个指针减去另一个指针 printf(&quot;\\n subtracting one pointer from another:\\n&quot;); printf(&quot;ptr2 = %p, ptr1 = %p, ptr2 - ptr1 = %td\\n&quot;, ptr2, ptr1, ptr2 - ptr1); return 0;&#125; 指针运算 给一个指针加表示要让指针指向下一个变量 123int a[10];int *p=a;*(p+1)==a[1]; 如果指针不是指向一片连续分配的空间, 如数组,则这种运算没有意义 给指针加、减一个整数 递增递减(++一) 两个指针相减 等于两个指针的绝对地址相减，再除以类型大小 *p++ 取出p所指的那个数据来,完事之后顺便把p移到下一个位置去 *的优先级虽然高,但是没有++高 常用于数组类的连续空间操作 在某些CPU上,这可以直接被翻译成一条汇编指令 指针比较 &lt;, &lt;= ,== ,&gt; ,&gt;= ,!= 都可以对指针做 比较它们在内存中的地址 数组中的单元的地址肯定是线性递增的 0地址 当然你的内存中有0地址,但是0地址通常是个不能随便碰的地址 所以你的指针不应该具有0值 因此可以用0地址来表示特殊的事情: 返回的指针是无效的 指针没有被真正初始化(先初始化为0) NULL是一个预定定义的符号,表示0地址 有的编译器不愿意你用0来表示0地址 指针的类型转换 void*表示不知道指向什么东西的指针 计算时与char*相同(但不相通) 指针也可以转换类型 12int*p =&amp;i; void*q=(void*)p; 这并没有改变p所指的变量的类型,而是让后人用不同的眼光通过p看它所指的变量 我不再当你是int啦,我认为你就是个void! 动态内存分配函数malloc123456789101112131415#include &lt;stdio&gt;#include &lt;stdlib.h&gt; int main(void)&#123; int number; int*a; int i; a=(int*)malloc(number*sizeof(int));//申请n*sizeof(int)个字节的内存空间 for(i=0;i&lt;number;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; free//把申请得来的空间还给“系统”&#125;//void*malloc(size_t size); 向 malloc申请的空间的大小是以字节为单位的 返回的结果是void*,需要类型转换为自己需要的类型 如果申请失败则返回0,或者叫做NULL free（） 把申请得来的空间还给“系统” 申请过的空间,最终都应该要还 只能还申请来的空间的首地址 常见问题： 申请了没free—-&gt;长时间运行内存逐渐下降 地址变过了,直接去free free过了再free","categories":[],"tags":[]},{"title":"","slug":"C语言：字符串","date":"2020-10-22T23:01:55.181Z","updated":"2020-10-01T09:47:32.297Z","comments":true,"path":"2020/10/23/C语言：字符串/","link":"","permalink":"http://example.com/2020/10/23/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串字符串是一个或者多个字符的序列，以空字符(\\0)结尾的char类型的数组。 C语言的字符串是以字符数组的形态存在的 不能用运算符对字符串做运算 通过数组的方式可以遍历字符串 以0(整数0)结尾的一串字符 0或‘\\0’是一样的,但是和‘0’不同 0标志字符串的结束,但它不是字符串的一部分 计算字符串长度的时候不包含这个0 字符串以数组的形式存在,以数组或指针的形式访问 更多的是以指针的形式 string.h里有很多处理字符串的函数 唯一特殊的地方是字符串字面量(” “)可以用来初始化字符数组 不需要再定义字符数组，在定义一个字符指针变量时，便在内存中开辟了一个字符数组用来存放该字符串常量。 字符串变量12345char *str =&quot;Hello&quot;; //给指针str所指向的字符数组写入Hellochar word[]=&quot;Hello&quot;;char line[10] =&quot;Hello&quot;; Hello 会被编译器变成一个字符数组放在某处,这个数组的长度是6,结尾还有表示结束的0. str是一个指针,初始化为指向一个字符串常量 由于这个常量所在的地方,所以实际上str是 const char *str但是由于历史的原因,编译器接受不带const的写法. 所以字符数组所存放的位置只能读不能写 字符串word[ ]可以修改 以数组形式 以指针形式 用于构造一个字符串 用于处理一个字符串 可读可写入 可读不可写入 作为本地变量空间自动被回收 处理参数 动态分配空间 字符串的输入与输出123char string[8];scanf(&quot;%s&quot;,string);//不加&amp;printf(&quot;%s&quot;, string); scanf读入一个单词(到空格、tab或回车为止) scanf是不安全的,因为不知道要读入的内容的长度 12char string[8];scanf(&quot;%7s&quot;, string); 在%和s之间的数字表示最多允许读入的字符的数量,这个数字应该比数组的大小少一 字符串数组 char **a a是一个指针,指向另一个指针,那个指针指向一个字符(串) 12345char a[5] [6]=&#123;&quot;hello&quot; &quot;world&quot; &quot;hello&quot; &quot;abcd&quot; &quot;efgh&quot;&#125;; char a[5] [6] : a[0] h e l l o \\0 a[1] w o r l d \\0 a[2] a b c d \\0 a[3] e f g h \\0 a[4] a[5] 字符串函数putchar1int putchar(int c): 向标准输出写一个字符 返回写了几个字符,EOF(-1)表示写入失败 getchar1int gerchar(void) 从标准输入读入一个字符 返回类型是int是为了返回EOF(-1) Windows-&gt;Ctrl-Z Unix-&gt;Ctrl-D strlen头文件 string.h 附#include&lt;ctype.h&gt;1 isalnum12#include &lt;ctype.h&gt;int sialnum(int ch); 变量为字母或数字时，函数返回非0值，否则返回0。 2 isalpha12#include &lt;ctype.h&gt;int isalpha(int ch); 当变量为字母表中的字母时，函数返回非0值，否则返回0。各种语言的字母表互不相同，对于英语来说，字母表由大写和小写的字母A到Z组成。 3 iscntrl12#include &lt;ctype.h&gt;int iscntrl(int ch); 当变量是控制字符时，函数返回非0，否则返回0。 4 isdigit12#include &lt;ctype.h&gt;int isdigit(int ch); 当变量是十进制数字时，函数返回非0值，否则返回0。 5 isgraph12#include &lt;ctype.h&gt;int isgraph(int ch); 如果变量为除空格之外的任何可打印字符，则函数返回非0值，否则返回0。 6 islower12#include &lt;ctype.h&gt;int islower(int ch); 如果变量是小写字母，函数返回非0值，否则返回0。 7 isprint12#include &lt;ctype.h&gt;int isprint(int ch); 如果变量是可打印字符(含空格)，则函数返回非0值，否则返回0。 8 ispunct12#include &lt;ctype.h&gt;int ispunct(int ch); 如果变量是除空格、字母和数字外的可打印字符，则函数返回非0，否则返回0。 9 isspace12#include &lt;ctype.h&gt;int isspace(int ch); 当变量为空白字符(包括空格、换页符、换行符、回车符、水平制表符和垂直制表符)时，函数返回非0，否则返回0。 10 isupper12#include &lt;ctype.h&gt;int isupper(int ch); 如果变量为大写字母，函数返回非0，否则返回0。 11 isxdigit12#include &lt;ctype.h&gt;int isxdigit(int ch); 当变量为十六进制数字时，函数返回非0，否则返回0。 12 tolower12#include &lt;ctype.h&gt;int tolower(int ch); 当ch为大写字母时，返回其对应的小写字母；否则返回ch。 13 toupper12#include &lt;ctype.h&gt;int toupper(int ch); 当ch为小写字母时，返回其对应的大写字母；否则返回ch。 程序参数*12345678#include &lt;stdio. h&gt;int main(int argc, char const *argv[])&#123; int i; for(i=0; i&lt;argc;i++)&#123; printf(&quot;%d:%s\\n&quot;,i,argv[i]) &#125; return 0; &#125; int main(int argc,char const *argv[ ]) argv[]是命令本身 当使用Unix的符号链接时,反映符号链接的名字","categories":[],"tags":[]},{"title":"","slug":"C语言：函数","date":"2020-10-22T23:01:55.177Z","updated":"2020-10-22T23:07:00.280Z","comments":true,"path":"2020/10/23/C语言：函数/","link":"","permalink":"http://example.com/2020/10/23/C%E8%AF%AD%E8%A8%80%EF%BC%9A%E5%87%BD%E6%95%B0/","excerpt":"","text":"123title:C语言：函数date: tags: C语言：函数函数的定义与使用函数：完成特定任务的独立程序代码单元 优势省去编写重复代码方便后期修改完善提高代码的可读性 函数定义1void sum (int begin,int end) void——函数头，指函数返回类型。（void表示函数没有返回类型）sum——函数名称(int begin,int end)——参数 调用函数函数名(参数值)( )起到了表示函数调用的重要作用即使没有参数也需要括号·如果有参数,则需要给出正确的数量和顺序 这些值会被按照顺序依次用来初始化函数中的参数如果函数有参数,调用函数时必须传递给它数量、类型正确的值 可以传递给函数的值是表达式的结果这包括： 字面量 变量 函数的返回值 结算的结果 函数先后关系 C的编译器自上而下顺序分析你的代码所以要先声明/定义出函数，再调用函数 函数声明提前告诉编译器你下面将要定义的函数类型同时会在下面检查声明与定义的函数类型是否相符(不会检查参数名称，所以在声明中可以不写参数名称只写类型，不过通常会写，方便阅读） 在没有参数时 12void f()void f(void) 前者在传统C中,它表示函数的参数表未知,并不表示没有参数注意：如果参数有类型，在声明时一定要写上，如果没有参数，也要写成后者形式 函数原型函数头,以分号“;结尾,构成了函数的原型用逗号分割的列表指明参数的数量和类型。 函数的参数与变量传值 （参数的转移）每个函数有自己的变量空间,参数也位于这个独立的空间中,和其他函数没有关系 \\过去,对于函数参数表中的参数,叫做形式参数”调用函数时给的值,叫做实际参数（形式参数属于本地/局部变量，为该函数私有） 本地变量 函数的每次运行,就产生了一个独立的变量空间,在这个空间中的变量,是函数的这次运行所独有的,称作本地变量（局部变量/自动变量） 定义在函数内部的变量就是本地变量 参数也是本地变量 变量的生存期和作用域生存期:什么时候这个变量开始出现了,到什么时候它消亡了 作用域:在(代码的)什么范围内可以访问这个变量(这个变量可以起作用) 对于本地变量,这两个问题的答案是统一的:大括号内——块 本地变量的规则 本地变量是定义在块内的 它可以是定义在函数的块内 也可以定义在语句的块内 甚至可以随便拉一对大括号来定义变量 程序运行进入这个块之前,其中的变量不存在,离开这个块,其中的变量就消失了 块外面定义的变量在里面仍然有效块里面定义了和外面同名的变量则掩盖了外面的（但不能在块内定义一个与外面同名的变量） 本地变量不会被默认初始化 参数在进入函数的时候被初始化了 细节 C语言不允许函数嵌套定义 int main()也是一个函数，可以写成 int main(void) return(0)返回0可表示该程序正常运行","categories":[],"tags":[]},{"title":"","slug":"C语言基础知识","date":"2020-10-22T23:01:55.173Z","updated":"2020-09-23T14:12:31.822Z","comments":true,"path":"2020/10/23/C语言基础知识/","link":"","permalink":"http://example.com/2020/10/23/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"C语言基础知识C程序的基本构成 预处理操作 定义主函数 变量定义 部分变量赋值（初始化赋值或赋值语句） 表达式计算（程序主体部分包括三种结构和算法） 输出结果（利用输出函数输出一组或多组结果) 程序正常结束 要点： 1.C程序是由(函数)构成的。 2.一个程序里(必须有)且(只能有)一个主函数。 3.主函数位置可以是(任意)的。 4.程序从(主函数)开始执行,在主函数中结束。 5.大括号作为(函数体)来定义和使用。 6.(分号)作为语句结束的基本标志。 7.C程序一行语句可以(分多行写),最后一行末尾必须有(分号)。 程序的执行过程程序语言发展历经: 机器语言(0和1), 汇编语言(低级语言), 高级语言(C语言) 程序执行的过程源程序(c)——编译(目标文件obj)——链接(可执行文件exe)——运行程序 编写好的程序称为(源程序)扩展名为(c) 对源程序文件进行(编译)操作,编译文件的扩展名为(obj) 对编译文件进行(链接)操作,链接文件的扩展名为(exe) 标识符的基本概念用户标识符 由（字母）（数字）（下划线）构成，且第一个字符不能为数字。 尽量以见名之意的形式命名 不能与C关键字相同 关键字预定义标识符","categories":[],"tags":[]},{"title":"第一篇博客","slug":"article-title","date":"2020-10-22T10:13:33.000Z","updated":"2020-10-22T12:31:45.433Z","comments":true,"path":"2020/10/22/article-title/","link":"","permalink":"http://example.com/2020/10/22/article-title/","excerpt":"","text":"Hello World格子格子的第一篇博客时间：10月22日 （嘿嘿，同时今天也是我的生日） （感谢室友的蛋糕，1129赛高！！） 突发奇想先搞一个自己的博客，以后可以上传一些自己的笔记，感想之类，感觉挺酷的 本来是只打算了解一下，当了解了解就动手做了起来 （本来是打算今天下午刷oj的） 哈哈，先暂时写这么多 现在它很很粗糙呢 以后会慢慢整改!","categories":[],"tags":[]},{"title":"第一篇博客","slug":"blog","date":"2020-10-22T10:13:33.000Z","updated":"2020-10-22T10:30:32.488Z","comments":true,"path":"2020/10/22/blog/","link":"","permalink":"http://example.com/2020/10/22/blog/","excerpt":"","text":"Hello World格子格子的第一篇博客时间：10月22日 （嘿嘿，同时今天也是我的生日） 突发奇想先搞一个自己的博客，以后可以上传一些自己的笔记，感想之类，感觉挺酷的 本来是只打算了解一下，当了解了解就动手做了起来 （本来是打算今天下午刷oj的） 哈哈，先暂时写这么多 现在它很很粗糙呢 以后会慢慢整改!","categories":[],"tags":[]}],"categories":[],"tags":[]}